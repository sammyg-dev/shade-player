#ifndef _SHADEPLAYER_INCLUDE_LAYER3D_HPP_
#define _SHADEPLAYER_INCLUDE_LAYER3D_HPP_
#define DEFAULT_ZINDEX 100

#include <vector>
#include <algorithm>
#include "ILayer.hpp"
#include "IDisplayObject.hpp"
#include "ModelDisplayObject.hpp"
#include <memory>

namespace shade {

  /** 
   * 
   *  Layer interface so different Layer types can be used within the same container and have
   *  a shared interface (LayerStack needs this)
   * 
   */
  class Layer3D: public ILayer {
    public:
      Layer3D(){

      }

      Layer3D(Rectangle rec){
        m_dimensions = rec;
      }

      ~Layer3D(){
        
      };

      void Init(const char* filePath, bool isReactive) override {
        // todo: pass camera in from scene? should all 3d layers share same camera?
        m_camera = { { 2.0f, 3.0f, 2.0f }, { 0.0f, 1.0f, 0.0f }, { 0.0f, 1.0f, 0.0f }, 45.0f, CAMERA_PERSPECTIVE };
        SetCameraMode(m_camera, CAMERA_ORBITAL);

        // todo: replace with loading from file generated by some kind of editor
        auto obj = make_shared<ModelDisplayObject>(ModelDisplayObject());
        obj->AddModel("resources/models/tree/scene.gltf", "resources/models/tree/textures/bark_baseColor.png");
        m_pDisplayObjects.push_back(obj);//idk if this is correct

         if(true){
          EventEmitter::On<FFTUpdateEvent>([&](FFTUpdateEvent& e) { OnFFTUpdate(e); });
        }
      };

      void OnFFTUpdate(FFTUpdateEvent &e){
        for(auto obj : m_pDisplayObjects){
          obj->UpdateScale(0.5f + e.RMS / 100.0f);
        }
      }

      void Render(float deltaTime, RenderTexture2D target) override {
        UpdateCamera(&m_camera);  
        BeginTextureMode(target);
        ClearBackground(BLANK);
        BeginMode3D(m_camera);

        for(auto obj : m_pDisplayObjects){
          obj->Render(deltaTime);
        }

        DrawGrid(10, 1.0f);

        EndMode3D();
        EndTextureMode();
        // we can blend layers by setting opacity...
        DrawTextureRec(target.texture, { 0, 0, target.texture.width, -target.texture.height }, { 0, 0 }, { 255, 255, 255, 125 });
      };

      // add and resort ??
      void AddObj(){
        //std::sort(m_pDisplayObjects.begin(), m_pDisplayObjects.end(), ZIndexComparator())
      }

    protected:
      std::vector<shared_ptr<IDisplayObject>> m_pDisplayObjects;
      Camera m_camera =  { { 2.0f, 3.0f, 2.0f }, { 0.0f, 1.0f, 0.0f }, { 0.0f, 1.0f, 0.0f }, 45.0f, 0 };

      virtual Layer3D* clone_impl() const override { return new Layer3D(*this); }
  };
}
#endif // _SHADEPLAYER_INCLUDE_LAYER3D_HPP_